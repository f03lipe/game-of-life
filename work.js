// Generated by CoffeeScript 1.4.0

/*

Rules:
	1. Any live cell with fewer than two live neighbours dies, as if caused by under-population.
	2. Any live cell with two or three live neighbours lives on to the next generation.
	3. Any live cell with more than three live neighbours dies, as if by overcrowding.
	4. Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

# Add
# STOP WHEN MOUSE DOWN
# fps counter
*/


(function() {
  
function rainbow(numOfSteps, step) {
    // This function generates vibrant, "evenly spaced" colours (i.e. no clustering). This is ideal for creating easily distiguishable vibrant markers in Google Maps and other apps.
    // Adam Cole, 2011-Sept-14
    // HSV to RBG adapted from: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
    var r, g, b;
    var h = step / numOfSteps;
    var i = ~~(h * 6);
    var f = h * 6 - i;
    var q = 1 - f;
    switch(i % 6){
        case 0: r = 1, g = f, b = 0; break;
        case 1: r = q, g = 1, b = 0; break;
        case 2: r = 0, g = 1, b = f; break;
        case 3: r = 0, g = q, b = 1; break;
        case 4: r = f, g = 0, b = 1; break;
        case 5: r = 1, g = 0, b = q; break;
    }
    var c = "#" + ("00" + (~ ~(r * 255)).toString(16)).slice(-2) + ("00" + (~ ~(g * 255)).toString(16)).slice(-2) + ("00" + (~ ~(b * 255)).toString(16)).slice(-2);
    return (c);
}
;

  var Board, CanvasObject, EventDispatcher, GridSquare, Painter, getRandColor,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  getRandColor = function() {
    return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);
  };

  CanvasObject = (function() {

    function CanvasObject() {}

    return CanvasObject;

  })();

  GridSquare = (function(_super) {

    __extends(GridSquare, _super);

    function GridSquare(size, c) {
      this.size = size;
      this.c = c;
    }

    GridSquare.prototype.render = function(context) {
      context.fillStyle = getRandColor();
      return context.fillRect(this.size * this.c.x, this.size * this.c.y, this.size, this.size);
    };

    GridSquare.prototype.clear = function(context) {
      return context.clearRect(this.size * this.c.x, this.size * this.c.y, this.size, this.size);
    };

    return GridSquare;

  })(CanvasObject);

  Board = (function() {

    Board.prototype.size = 10;

    Board.prototype.board = [];

    Board.prototype.DEAD = null;

    Board.prototype.ALIVE = 1;

    function Board(canvas, pop) {
      var i, _i;
      this.canvas = canvas;
      if (pop == null) {
        pop = null;
      }
      this.toogleSquare = __bind(this.toogleSquare, this);

      this.context = this.canvas.getContext("2d");
      this.WIDTH = ~~(this.canvas.width / this.size) + 1;
      this.HEIGHT = ~~(this.canvas.height / this.size) + 1;
      window.canvas = this.canvas;
      this._drawGrid();
      this.genInitialState();
      if (pop == null) {
        pop = this.WIDTH * this.HEIGHT * .1;
      }
      for (i = _i = 1; 1 <= pop ? _i <= pop : _i >= pop; i = 1 <= pop ? ++_i : --_i) {
        this.addSquare(this._getRandBoardPos());
      }
      this.render(this.board);
    }

    Board.prototype.genInitialState = function() {
      var board, i, i2, _i, _j, _ref, _ref1;
      console.log("Initializing board " + this.WIDTH + " by " + this.HEIGHT);
      board = [];
      for (i = _i = 0, _ref = this.WIDTH; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        board[i] = Array(this.HEIGHT);
        for (i2 = _j = 0, _ref1 = this.HEIGHT; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i2 = 0 <= _ref1 ? ++_j : --_j) {
          board[i][i2] = this.DEAD;
        }
      }
      this.board = board;
      return this.render();
    };

    Board.prototype.addSquare = function(coord) {
      return this.board[coord.x][coord.y] = this.ALIVE;
    };

    Board.prototype.toogleSquare = function(c) {
      if (this.board[c.x][c.y]) {
        new GridSquare(this.size, c).clear(this.context);
        return this.board[c.x][c.y] = this.DEAD;
      } else {
        new GridSquare(this.size, c).render(this.context);
        return this.board[c.x][c.y] = this.ALIVE;
      }
    };

    Board.prototype.render = function(board) {
      var x, y, _i, _j, _ref, _ref1;
      if (board == null) {
        board = this.board;
      }
      this.clear();
      for (x = _i = 0, _ref = board.length; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = board[x].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          if (board[x][y]) {
            new GridSquare(this.size, {
              x: x,
              y: y
            }).render(this.context);
          }
        }
      }
    };

    Board.prototype.renderToggle = function(board) {
      var x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = board.length; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (y = _j = 0, _ref1 = board[x].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            if (board[x][y] !== this.board[x][y]) {
              if (!board[x][y]) {
                _results1.push(new GridSquare(this.size, {
                  x: x,
                  y: y
                }).clear(this.context));
              } else {
                _results1.push(new GridSquare(this.size, {
                  x: x,
                  y: y
                }).render(this.context));
              }
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Board.prototype.tick = function() {
      var board, neighbours, status, x, y, _i, _j, _k, _ref, _ref1, _ref2;
      board = Array(this.WIDTH);
      for (x = _i = 0, _ref = this.WIDTH; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        board[x] = this.board[x].slice(0);
      }
      if (this.mouse === true) {
        return;
      }
      for (x = _j = 0, _ref1 = this.WIDTH; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        for (y = _k = 0, _ref2 = this.HEIGHT; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
          status = this.board[x][y];
          neighbours = this._countNeighbours(x, y);
          switch (status) {
            case this.DEAD:
              switch (neighbours) {
                case 3:
                  board[x][y] = this.ALIVE;
              }
              break;
            case this.ALIVE:
              switch (neighbours) {
                case 2:
                case 3:
                case 4:
                  break;
                default:
                  board[x][y] = this.DEAD;
              }
          }
        }
      }
      this.renderToggle(board);
      return this.board = board;
    };

    Board.prototype.clear = function() {
      return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    Board.prototype.resetListeners = function() {
      return pass;
    };

    Board.prototype._countNeighbours = function(x, y) {
      var count, s, s2, _i, _j;
      count = 0;
      for (s = _i = -1; _i <= 1; s = ++_i) {
        if (this.board[x + s]) {
          for (s2 = _j = -1; _j <= 1; s2 = ++_j) {
            if (this.board[x + s][y + s2] && !((s === s2 && s2 === 0))) {
              count += 1;
            }
          }
        }
      }
      return count;
    };

    Board.prototype._drawGrid = function() {
      var SIZE, canvas2, context2, icol, iline, makeLine, _i, _j, _ref, _ref1, _results;
      canvas2 = document.querySelector("canvas#grid");
      context2 = canvas2.getContext("2d");
      makeLine = function(x, y, x2, y2) {
        context2.beginPath();
        context2.moveTo(x, y);
        context2.lineTo(x2, y2);
        return context2.stroke();
      };
      SIZE = this.size;
      context2.lineWidth = .1;
      for (icol = _i = 0, _ref = canvas2.width / SIZE; 0 <= _ref ? _i < _ref : _i > _ref; icol = 0 <= _ref ? ++_i : --_i) {
        makeLine(SIZE * icol, 0, SIZE * icol, canvas2.height);
      }
      _results = [];
      for (iline = _j = 0, _ref1 = canvas2.height / SIZE; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; iline = 0 <= _ref1 ? ++_j : --_j) {
        _results.push(makeLine(0, SIZE * iline, canvas2.width, SIZE * iline));
      }
      return _results;
    };

    Board.prototype._printBoard = function(board) {
      var line, x, y, _i, _j, _ref, _ref1, _results;
      if (board == null) {
        board = this.board;
      }
      _results = [];
      for (y = _i = 0, _ref = this.HEIGHT; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        line = [];
        for (x = _j = 0, _ref1 = this.WIDTH; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          line.push(board[x][y] ? 1 : 0);
        }
        _results.push(console.log(line.join(', ')));
      }
      return _results;
    };

    Board.prototype._getRandBoardPos = function() {
      return {
        x: Math.floor(Math.random() * this.WIDTH),
        y: Math.floor(Math.random() * this.HEIGHT)
      };
    };

    return Board;

  })();

  EventDispatcher = (function() {
    var _getMousePos;

    function EventDispatcher(board) {
      this.canvasClicked = __bind(this.canvasClicked, this);

      this.inCanvas = __bind(this.inCanvas, this);

      this.outCanvas = __bind(this.outCanvas, this);
      this.board = board;
      this.canvas = board.canvas;
      console.log("Attaching listeners to " + board);
      $(canvas).on('click', this.canvasClicked);
      $(canvas).on('mouseover', this.inCanvas);
      $(canvas).on('mouseout', this.outCanvas);
      $(canvas).on('mousemove mousedown', this.mousemove);
    }

    _getMousePos = function(canvas, event) {
      var rect;
      rect = canvas.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    };

    EventDispatcher.prototype.outCanvas = function(event) {
      return this.board.mouseon = false;
    };

    EventDispatcher.prototype.inCanvas = function(event) {
      return this.board.mouseon = true;
    };

    EventDispatcher.prototype.canvasClicked = function(event) {
      var boardPos, mousePos;
      mousePos = _getMousePos(this.canvas, event);
      boardPos = {
        x: ~~(mousePos.x / this.board.size),
        y: ~~(mousePos.y / this.board.size)
      };
      console.log("Canvas click fired at (" + mousePos.x + "," + mousePos.y + ") => (" + boardPos.x + "," + boardPos.y + ")");
      return this.board.toogleSquare(boardPos);
    };

    return EventDispatcher;

  })();

  window.drawDot = function(canvas, x, y) {
    console.log(canvas);
    window.context = canvas.getContext("2d");
    context.strokeStyle = "black";
    context.beginPath();
    context.arc(x, y, 2, 0, 2 * Math.PI, true);
    return context.fill();
  };

  Painter = (function() {

    function Painter() {}

    Painter.prototype.buildCanvas = function() {
      var elm, id, _ref, _results;
      this.canvas = {
        grid: document.createElement("canvas"),
        board: document.createElement("canvas")
      };
      _ref = this.canvas;
      _results = [];
      for (id in _ref) {
        elm = _ref[id];
        elm.id = id;
        elm.width = window.innerWidth;
        elm.height = window.innerHeight;
        _results.push($(elm).appendTo($(".wrapper")));
      }
      return _results;
    };

    Painter.prototype.loop = function() {
      var board,
        _this = this;
      board = new Board(this.canvas.board);
      console.log(board);
      new EventDispatcher(board);
      return window.setInterval(function() {
        return board.tick();
      }, 100);
    };

    return Painter;

  })();

  window.AnimateOnFrameRate = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

  window.onload = function() {
    var painter;
    painter = new Painter;
    painter.buildCanvas();
    painter.loop();
  };

}).call(this);

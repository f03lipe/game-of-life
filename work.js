// Generated by CoffeeScript 1.4.0

/*

Rules from Wikipedia (http://en.wikipedia.org/wiki/Conway's_Game_of_Life)
1. Any live cell with fewer than two live neighbours dies, as if caused by under-population.
2. Any live cell with two or three live neighbours lives on to the next generation.
3. Any live cell with more than three live neighbours dies, as if by overcrowding.
4. Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

# Add
# fps counter
*/


(function() {
  var Board, EventDispatcher, GridSquare, Painter, getRandColor, rainbow,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  rainbow = function(numOfSteps, step) {
    var b, c, f, g, h, i, q, r;
    h = step / numOfSteps;
    i = ~~(h * 6);
    f = h * 6 - i;
    q = 1 - f;
    switch (i % 6) {
      case 0:
        r = 1;
        g = f;
        b = 0;
        break;
      case 1:
        r = q;
        g = 1;
        b = 0;
        break;
      case 2:
        r = 0;
        g = 1;
        b = f;
        break;
      case 3:
        r = 0;
        g = q;
        b = 1;
        break;
      case 4:
        r = f;
        g = 0;
        b = 1;
        break;
      case 5:
        r = 1;
        g = 0;
        b = q;
    }
    c = "#" + ("00" + (~~(r * 255)).toString(16)).slice(-2) + ("00" + (~~(g * 255)).toString(16)).slice(-2) + ("00" + (~~(b * 255)).toString(16)).slice(-2);
    return c;
  };

  getRandColor = function() {
    return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);
  };

  GridSquare = (function() {

    function GridSquare(size, c) {
      this.size = size;
      this.c = c;
    }

    GridSquare.prototype.render = function(context) {
      context.fillStyle = rainbow(this.c.x + this.c.y, 10);
      return context.fillRect(this.size * this.c.x, this.size * this.c.y, this.size, this.size);
    };

    GridSquare.prototype.clear = function(context) {
      return context.clearRect(this.size * this.c.x, this.size * this.c.y, this.size, this.size);
    };

    return GridSquare;

  })();

  Board = (function() {

    Board.prototype.boardState = [];

    Board.prototype.DEAD = null;

    Board.prototype.ALIVE = 1;

    function Board(canvas, gridSize, initPopulation) {
      var _ref;
      this.canvas = canvas;
      this.gridSize = gridSize != null ? gridSize : 10;
      this.initPopulation = initPopulation != null ? initPopulation : null;
      this.toogleSquare = __bind(this.toogleSquare, this);

      this.context = this.canvas.getContext("2d");
      this.WIDTH = ~~(this.canvas.width / this.gridSize) + 1;
      this.HEIGHT = ~~(this.canvas.height / this.gridSize) + 1;
      if ((_ref = this.initPopulation) == null) {
        this.initPopulation = this.WIDTH * this.HEIGHT * .5;
      }
      this.resetBoard();
    }

    Board.prototype.initializeBoard = function() {
      var boardState, i, i2, _i, _j, _ref, _ref1;
      console.log("Initializing boardState " + this.WIDTH + " by " + this.HEIGHT);
      boardState = [];
      for (i = _i = 0, _ref = this.WIDTH; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        boardState[i] = Array(this.HEIGHT);
        for (i2 = _j = 0, _ref1 = this.HEIGHT; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i2 = 0 <= _ref1 ? ++_j : --_j) {
          boardState[i][i2] = this.DEAD;
        }
      }
      this.boardState = boardState;
      return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    Board.prototype.resetBoard = function(pop) {
      var i, _i, _results;
      if (pop == null) {
        pop = this.initPopulation;
      }
      this.initializeBoard();
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      _results = [];
      for (i = _i = 1; 1 <= pop ? _i <= pop : _i >= pop; i = 1 <= pop ? ++_i : --_i) {
        _results.push(this.toogleSquare(this._getRandBoardPos()));
      }
      return _results;
    };

    Board.prototype.clearBoard = function() {
      this.initializeBoard();
      return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    Board.prototype.addSquare = function(coord) {
      this.boardState[coord.x][coord.y] = this.ALIVE;
      return new GridSquare(this.gridSize, coord).render(this.context);
    };

    Board.prototype.toogleSquare = function(coord) {
      if (this.boardState[coord.x][coord.y]) {
        new GridSquare(this.gridSize, coord).clear(this.context);
        return this.boardState[coord.x][coord.y] = this.DEAD;
      } else {
        new GridSquare(this.gridSize, coord).render(this.context);
        return this.boardState[coord.x][coord.y] = this.ALIVE;
      }
    };

    Board.prototype.render = function(newState) {
      var x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = newState.length; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        if (!_.isEqual(newState[x], this.boardState[x])) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (y = _j = 0, _ref1 = newState[x].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
              if (newState[x][y] !== this.boardState[x][y]) {
                if (!newState[x][y]) {
                  _results1.push(new GridSquare(this.gridSize, {
                    x: x,
                    y: y
                  }).clear(this.context));
                } else {
                  _results1.push(new GridSquare(this.gridSize, {
                    x: x,
                    y: y
                  }).render(this.context));
                }
              }
            }
            return _results1;
          }).call(this));
        }
      }
      return _results;
    };

    Board.prototype.tic = function() {
      var boardState, changed, neighbours, status, x, y, _i, _j, _k, _ref, _ref1, _ref2;
      boardState = Array(this.WIDTH);
      for (x = _i = 0, _ref = this.WIDTH; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        boardState[x] = this.boardState[x].slice(0);
      }
      changed = false;
      for (x = _j = 0, _ref1 = this.WIDTH; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        for (y = _k = 0, _ref2 = this.HEIGHT; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
          status = this.boardState[x][y];
          neighbours = this._countNeighbours(x, y);
          switch (status) {
            case this.DEAD:
              switch (neighbours) {
                case 3:
                  boardState[x][y] = this.ALIVE;
                  changed = true;
              }
              break;
            case this.ALIVE:
              switch (neighbours) {
                case 2:
                case 3:
                  break;
                default:
                  boardState[x][y] = this.DEAD;
                  changed = true;
              }
          }
        }
      }
      this.render(boardState);
      this.boardState = boardState;
      if (changed) {
        return $(this).trigger('toc', {
          empty: this._isEmptyBoard(this.boardState)
        });
      }
    };

    Board.prototype._countNeighbours = function(x, y) {
      var count, s, s2, _i, _j;
      count = 0;
      for (s = _i = -1; _i <= 1; s = ++_i) {
        if (this.boardState[x + s]) {
          for (s2 = _j = -1; _j <= 1; s2 = ++_j) {
            if (this.boardState[x + s][y + s2] && !((s === s2 && s2 === 0))) {
              count += 1;
            }
          }
        }
      }
      return count;
    };

    Board.prototype._printBoard = function(boardState) {
      var line, x, y, _i, _j, _ref, _ref1, _results;
      if (boardState == null) {
        boardState = this.boardState;
      }
      _results = [];
      for (y = _i = 0, _ref = this.HEIGHT; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        line = [];
        for (x = _j = 0, _ref1 = this.WIDTH; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          line.push(boardState[x][y] ? 1 : 0);
        }
        _results.push(console.log(line.join(', ')));
      }
      return _results;
    };

    Board.prototype._getRandBoardPos = function() {
      return {
        x: Math.floor(Math.random() * this.WIDTH),
        y: Math.floor(Math.random() * this.HEIGHT)
      };
    };

    Board.prototype._isEmptyBoard = function(boardState) {
      var x, y, _i, _j, _ref, _ref1;
      if (boardState == null) {
        boardState = this.boardState;
      }
      for (x = _i = 0, _ref = this.WIDTH; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.HEIGHT; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          if (boardState[x][y] !== this.DEAD) {
            return false;
          }
        }
      }
      return true;
    };

    return Board;

  })();

  EventDispatcher = (function() {

    EventDispatcher.lastHoveredSquare = null;

    EventDispatcher.prototype._getMousePos = function(event) {
      var rect;
      rect = this.canvas.getBoundingClientRect();
      return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
      };
    };

    EventDispatcher.prototype._getGridPos = function(event) {
      var coord;
      coord = this._getMousePos(event);
      return {
        x: ~~(coord.x / this.board.gridSize),
        y: ~~(coord.y / this.board.gridSize)
      };
    };

    function EventDispatcher(painter) {
      this.painter = painter;
      this.updateStateCounter = __bind(this.updateStateCounter, this);

      this._getGridPos = __bind(this._getGridPos, this);

      this._getMousePos = __bind(this._getMousePos, this);

    }

    EventDispatcher.prototype.setBoard = function(board) {
      this.board = board;
      this.canvas = board.canvas;
      console.log("Attaching listeners to board:", this.detectMouse());
      this.detectSpacebar();
      this.detectMousePos();
      this.detectCanvasClick;
      this.detectCanvasClick();
      this.detectMouseMove();
      this.bindBoardToc();
      this.bindStopButton();
      this.bindClearButton();
      this.bindShowPanel();
      this.bindHideGrid();
      return this.bindBuildBoard();
    };

    EventDispatcher.prototype.bindBoardToc = function() {
      var _this = this;
      window.stateCount = 0;
      return $(this.board).bind('toc', function(event, context) {
        if (!context.empty) {
          window.stateCount += 1;
          return _this.updateStateCounter();
        }
      });
    };

    EventDispatcher.prototype.bindStopButton = function() {
      var _this = this;
      return $('body').on('click', 'button.haltboard', function(event) {
        if ($(event.target).hasClass('active')) {
          window.canvasStop = false;
        } else {
          window.canvasStop = true;
        }
        return true;
      });
    };

    EventDispatcher.prototype.bindClearButton = function() {
      var _this = this;
      return $("button.clearboard").click(function(event) {
        window.stateCount = 0;
        _this.board.clearBoard();
        return _this.updateStateCounter();
      });
    };

    EventDispatcher.prototype.bindShowPanel = function() {
      var _this = this;
      return $(".show-more").click(function(event) {
        if ($('.config-panel').is(':hidden')) {
          $('.config-panel').slideDown();
          $(".show-more").find("h6").html('show less options');
          $(".show-more").find("i").removeClass("icon-circle-arrow-down").addClass("icon-circle-arrow-up");
          $(".grid-size").val(_this.board.gridSize);
          return console.log(_this.board.gridSize);
        } else {
          $('.config-panel').slideUp();
          $(".show-more").find("h6").html('show more options');
          return $(".show-more").find("i").removeClass("icon-circle-arrow-up").addClass("icon-circle-arrow-down");
        }
      });
    };

    EventDispatcher.prototype.bindHideGrid = function() {
      var _this = this;
      return $("button.hidegrid").click(function(event) {
        if ($("button.hidegrid").hasClass("active")) {
          return $("canvas#grid").fadeIn();
        } else {
          return $("canvas#grid").fadeOut();
        }
      });
    };

    EventDispatcher.prototype.bindBuildBoard = function() {
      var _this = this;
      return $("button.buildboard").click(function(event) {
        var fps, particles, size;
        particles = $(".initial-particles").val();
        size = $(".grid-size").val();
        fps = $(".refresh-rate").val();
        console.log(fps, particles, size);
        delete window.painter;
        return _this.painter.buildBoard(fps, size, particles);
      });
    };

    EventDispatcher.prototype.updateStateCounter = function() {
      return document.querySelector(".count").innerHTML = window.stateCount;
    };

    EventDispatcher.prototype.detectMouse = function() {
      var _this = this;
      window.mouseDown = false;
      $(document).mousedown(function(event) {
        return window.mouseDown = true;
      });
      return $(document).mouseup(function(event) {
        return window.mouseDown = false;
      });
    };

    EventDispatcher.prototype.detectSpacebar = function() {
      var _this = this;
      window.canvasStop = false;
      return $(document).keydown(function(event) {
        if (event.keyCode === 32) {
          if (window.canvasStop) {
            $("button.haltboard").removeClass('active');
            return window.canvasStop = false;
          } else {
            $("button.haltboard").addClass('active');
            return window.canvasStop = true;
          }
        }
      });
    };

    EventDispatcher.prototype.detectMousePos = function() {
      window.mouseOverCanvas = false;
      $(this.canvas).mouseover(function(event) {
        return window.mouseOverCanvas = true;
      });
      return $(this.canvas).mouseout(function(event) {
        return window.mouseOuverCanvas = false;
      });
    };

    EventDispatcher.prototype.detectCanvasClick = function() {
      var _this = this;
      return $(this.canvas).mousedown(function(event) {
        var coord;
        console.log("oi1");
        if (!window.mouseOverCanvas) {
          return;
        }
        console.log("oi2");
        coord = _this._getGridPos(event);
        if (!_.isEqual(coord, _this.lastHoveredSquare)) {
          console.log("Click on canvas fired at", coord);
          return _this.board.toogleSquare(coord);
        }
      });
    };

    EventDispatcher.prototype.detectMouseMove = function() {
      var _this = this;
      return $(this.canvas).mousemove(function(event) {
        var coord;
        if (window.mouseOverCanvas && window.mouseDown) {
          coord = _this._getGridPos(event);
          if (!_.isEqual(coord, _this.lastHoveredSquare)) {
            _this.lastHoveredSquare = coord;
            _this.board.addSquare(coord);
            console.log("Hovering board at square", coord);
          }
          return _this.lastHoveredSquare = coord;
        }
      });
    };

    return EventDispatcher;

  })();

  Painter = (function() {
    var drawDot, drawGrid, makeLine;

    drawDot = function(context, x, y, color) {
      if (color == null) {
        color = "black";
      }
      context.strokeStyle = color;
      context.beginPath();
      context.arc(x, y, 2, 0, 2 * Math.PI, true);
      return context.fill();
    };

    makeLine = function(context, x, y, x2, y2, lineWidth, color) {
      if (lineWidth == null) {
        lineWidth = 0.1;
      }
      if (color == null) {
        color = "black";
      }
      context.strokeStyle = color;
      context.lineWidth = lineWidth;
      context.beginPath();
      context.moveTo(x, y);
      context.lineTo(x2, y2);
      return context.stroke();
    };

    drawGrid = function(canvas, gridSize) {
      var context, icol, iline, _i, _j, _ref, _ref1, _results;
      context = canvas.getContext("2d");
      for (icol = _i = 0, _ref = canvas.width / gridSize; 0 <= _ref ? _i < _ref : _i > _ref; icol = 0 <= _ref ? ++_i : --_i) {
        makeLine(context, gridSize * icol, 0, gridSize * icol, canvas.height, .1, 'grey');
      }
      _results = [];
      for (iline = _j = 0, _ref1 = canvas.height / gridSize; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; iline = 0 <= _ref1 ? ++_j : --_j) {
        _results.push(makeLine(context, 0, gridSize * iline, canvas.width, gridSize * iline, .1, 'grey'));
      }
      return _results;
    };

    Painter.prototype.gridSize = 10;

    Painter.prototype.initialPop = 1000;

    Painter.prototype.fps = 100;

    function Painter() {
      var elm, id, _ref;
      this.canvas = {
        grid: document.createElement("canvas"),
        board: document.createElement("canvas")
      };
      _ref = this.canvas;
      for (id in _ref) {
        elm = _ref[id];
        elm.id = id;
        elm.width = $(window).width();
        elm.height = $(window).height();
        $(elm).appendTo($(".wrapper"));
      }
      drawGrid(this.canvas.grid, this.gridSize);
      this.buildBoard();
    }

    Painter.prototype.buildBoard = function(fps, gridSize, initialPop) {
      this.fps = fps != null ? fps : this.fps;
      this.gridSize = gridSize != null ? gridSize : this.gridSize;
      this.initialPop = initialPop != null ? initialPop : this.initialPop;
      console.log("@board", this.board);
      this.board = new Board(this.canvas.board, this.gridSize, this.initialPop);
      this.dispatcher = new EventDispatcher(this);
      return this.dispatcher.setBoard(this.board);
    };

    Painter.prototype._loop = function() {
      var _this = this;
      window.setTimeout(function() {
        return _this._loop();
      }, 1000 / this.fps);
      if (window.canvasStop || window.mouseDown && window.mouseOverCanvas) {
        return;
      }
      console.log("tic");
      return this.board.tic();
    };

    Painter.prototype.loop = function() {
      console.log("Start looping board");
      return this._loop();
    };

    return Painter;

  })();

  window.AnimateOnFrameRate = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

  window.onload = function() {
    window.painter = new Painter(20, 100);
    window.painter.loop();
  };

}).call(this);

// Generated by CoffeeScript 1.4.0
(function() {
  var GridSquare, getRandColor, rainbow,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  rainbow = function(numOfSteps, step) {
    var b, c, f, g, h, i, q, r;
    h = step / numOfSteps;
    i = ~~(h * 6);
    f = h * 6 - i;
    q = 1 - f;
    switch (i % 6) {
      case 0:
        r = 1;
        g = f;
        b = 0;
        break;
      case 1:
        r = q;
        g = 1;
        b = 0;
        break;
      case 2:
        r = 0;
        g = 1;
        b = f;
        break;
      case 3:
        r = 0;
        g = q;
        b = 1;
        break;
      case 4:
        r = f;
        g = 0;
        b = 1;
        break;
      case 5:
        r = 1;
        g = 0;
        b = q;
    }
    c = "#" + ("00" + (~~(r * 255)).toString(16)).slice(-2) + ("00" + (~~(g * 255)).toString(16)).slice(-2) + ("00" + (~~(b * 255)).toString(16)).slice(-2);
    return c;
  };

  getRandColor = function() {
    return '#' + (Math.random() * 0xFFFFFF << 0).toString(16);
  };

  GridSquare = (function() {

    function GridSquare(size, c) {
      this.size = size;
      this.c = c;
    }

    GridSquare.prototype.render = function(context) {
      context.fillStyle = rainbow(this.c.x + this.c.y, 10);
      return context.fillRect(this.size * this.c.x, this.size * this.c.y, this.size, this.size);
    };

    GridSquare.prototype.clear = function(context) {
      return context.clearRect(this.size * this.c.x, this.size * this.c.y, this.size, this.size);
    };

    return GridSquare;

  })();

  window.Board = (function() {

    Board.prototype.boardState = [];

    Board.prototype.DEAD = null;

    Board.prototype.ALIVE = 1;

    function Board(canvas, gridSize, pop) {
      this.canvas = canvas;
      if (gridSize == null) {
        gridSize = 10;
      }
      if (pop == null) {
        pop = null;
      }
      this.toogleSquare = __bind(this.toogleSquare, this);

      this.context = this.canvas.getContext("2d");
      if (pop == null) {
        pop = this.WIDTH * this.HEIGHT * .5;
      }
      this.resetBoard(pop, gridSize);
    }

    Board.prototype.initializeBoard = function() {
      var boardState, i, i2, _i, _j, _ref, _ref1;
      console.log("Initializing boardState " + this.WIDTH + " by " + this.HEIGHT);
      boardState = [];
      for (i = _i = 0, _ref = this.WIDTH; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        boardState[i] = Array(this.HEIGHT);
        for (i2 = _j = 0, _ref1 = this.HEIGHT; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i2 = 0 <= _ref1 ? ++_j : --_j) {
          boardState[i][i2] = this.DEAD;
        }
      }
      this.boardState = boardState;
      return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    Board.prototype.resetBoard = function(initialPop, gridSize) {
      var i, _i, _ref, _results;
      this.initialPop = initialPop != null ? initialPop : this.initialPop;
      this.gridSize = gridSize != null ? gridSize : this.gridSize;
      this.WIDTH = ~~(this.canvas.width / this.gridSize) + 1;
      this.HEIGHT = ~~(this.canvas.height / this.gridSize) + 1;
      this.initializeBoard();
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      _results = [];
      for (i = _i = 1, _ref = this.initialPop; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        _results.push(this.toogleSquare(this._getRandBoardPos()));
      }
      return _results;
    };

    Board.prototype.clearBoard = function() {
      this.initializeBoard();
      return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    Board.prototype.addSquare = function(coord) {
      this.boardState[coord.x][coord.y] = this.ALIVE;
      return new GridSquare(this.gridSize, coord).render(this.context);
    };

    Board.prototype.toogleSquare = function(coord) {
      if (this.boardState[coord.x][coord.y]) {
        new GridSquare(this.gridSize, coord).clear(this.context);
        return this.boardState[coord.x][coord.y] = this.DEAD;
      } else {
        new GridSquare(this.gridSize, coord).render(this.context);
        return this.boardState[coord.x][coord.y] = this.ALIVE;
      }
    };

    Board.prototype.render = function(newState) {
      var x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = newState.length; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        if (!_.isEqual(newState[x], this.boardState[x])) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (y = _j = 0, _ref1 = newState[x].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
              if (newState[x][y] !== this.boardState[x][y]) {
                if (!newState[x][y]) {
                  _results1.push(new GridSquare(this.gridSize, {
                    x: x,
                    y: y
                  }).clear(this.context));
                } else {
                  _results1.push(new GridSquare(this.gridSize, {
                    x: x,
                    y: y
                  }).render(this.context));
                }
              }
            }
            return _results1;
          }).call(this));
        }
      }
      return _results;
    };

    Board.prototype.tic = function() {
      var boardState, changed, neighbours, status, x, y, _i, _j, _k, _ref, _ref1, _ref2;
      boardState = Array(this.WIDTH);
      for (x = _i = 0, _ref = this.WIDTH; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        boardState[x] = this.boardState[x].slice(0);
      }
      changed = false;
      for (x = _j = 0, _ref1 = this.WIDTH; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
        for (y = _k = 0, _ref2 = this.HEIGHT; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
          status = this.boardState[x][y];
          neighbours = this._countNeighbours(x, y);
          switch (status) {
            case this.DEAD:
              switch (neighbours) {
                case 3:
                  boardState[x][y] = this.ALIVE;
                  changed = true;
              }
              break;
            case this.ALIVE:
              switch (neighbours) {
                case 2:
                case 3:
                  break;
                default:
                  boardState[x][y] = this.DEAD;
                  changed = true;
              }
          }
        }
      }
      this.render(boardState);
      this.boardState = boardState;
      if (changed) {
        return $(this).trigger('toc', {
          empty: this._isEmptyBoard(this.boardState)
        });
      }
    };

    Board.prototype._countNeighbours = function(x, y) {
      var count, s, s2, _i, _j;
      count = 0;
      for (s = _i = -1; _i <= 1; s = ++_i) {
        if (this.boardState[x + s]) {
          for (s2 = _j = -1; _j <= 1; s2 = ++_j) {
            if (this.boardState[x + s][y + s2] && !((s === s2 && s2 === 0))) {
              count += 1;
            }
          }
        }
      }
      return count;
    };

    Board.prototype._printBoard = function(boardState) {
      var line, x, y, _i, _j, _ref, _ref1, _results;
      if (boardState == null) {
        boardState = this.boardState;
      }
      _results = [];
      for (y = _i = 0, _ref = this.HEIGHT; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        line = [];
        for (x = _j = 0, _ref1 = this.WIDTH; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          line.push(boardState[x][y] ? 1 : 0);
        }
        _results.push(console.log(line.join(', ')));
      }
      return _results;
    };

    Board.prototype._getRandBoardPos = function() {
      return {
        x: Math.floor(Math.random() * this.WIDTH),
        y: Math.floor(Math.random() * this.HEIGHT)
      };
    };

    Board.prototype._isEmptyBoard = function(boardState) {
      var x, y, _i, _j, _ref, _ref1;
      if (boardState == null) {
        boardState = this.boardState;
      }
      for (x = _i = 0, _ref = this.WIDTH; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.HEIGHT; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          if (boardState[x][y] !== this.DEAD) {
            return false;
          }
        }
      }
      return true;
    };

    return Board;

  })();

}).call(this);
